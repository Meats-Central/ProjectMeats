# =============================================================================
# UNIFIED DEPLOYMENT WORKFLOW (FIXED VERSION)
# =============================================================================
# This workflow combines all 4 separate deployment workflows with simplified
# triggering logic to avoid job skipping issues.
# =============================================================================

name: Deploy to Development, UAT & Production

# =============================================================================
# TRIGGERS - Simplified approach
# =============================================================================
on:
  push:
    branches: [ main, development ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - rollback

# =============================================================================
# JOBS - With proper conditional logic
# =============================================================================
jobs:
  # ===========================================================================
  # DETECT CHANGES - Determine what files changed
  # ===========================================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'rollback'
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for change detection

      - name: Detect changed files
        id: changes
        run: |
          # Check what files changed in the last commit
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "backend=true" >> $GITHUB_OUTPUT
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - will run all jobs"
          else
            # Get changed files from the last commit
            changed_files=$(git diff --name-only HEAD^ HEAD)
            echo "Changed files: $changed_files"

            # Check for backend changes
            if echo "$changed_files" | grep -q "^backend/"; then
              echo "backend=true" >> $GITHUB_OUTPUT
              echo "Backend changes detected"
            else
              echo "backend=false" >> $GITHUB_OUTPUT
              echo "No backend changes"
            fi

            # Check for frontend changes
            if echo "$changed_files" | grep -q "^frontend/"; then
              echo "frontend=true" >> $GITHUB_OUTPUT
              echo "Frontend changes detected"
            else
              echo "frontend=false" >> $GITHUB_OUTPUT
              echo "No frontend changes"
            fi
          fi

  # ===========================================================================
  # BACKEND TESTING
  # ===========================================================================
  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.backend == 'true'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üêç Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: üì¶ Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: üì• Install dependencies
      working-directory: ./backend
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: üìÅ Ensure logs directory exists
      working-directory: ./backend
      run: mkdir -p logs

    - name: üîß Setup test environment
      working-directory: ./backend
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        SECRET_KEY: test-secret-key-for-testing-only
        DEBUG: True
      run: |
        python manage.py check
        python manage.py migrate

    - name: üîç Check migration consistency
      working-directory: ./backend
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        SECRET_KEY: test-secret-key-for-testing-only
        DEBUG: True
      run: |
        echo "Checking for unapplied migrations..."
        python manage.py makemigrations --check --dry-run || {
          echo "‚ùå Error: Unapplied migrations detected!"
          echo "Please run 'python manage.py makemigrations' locally and commit the migration files."
          exit 1
        }
        echo "‚úÖ No unapplied migrations detected"
        
        echo "Verifying migration dependencies..."
        python manage.py migrate --plan || {
          echo "‚ùå Error: Migration dependency issues detected!"
          echo "Check migration files for circular dependencies or missing dependencies."
          exit 1
        }
        echo "‚úÖ Migration dependencies are consistent"

    - name: üß™ Run tests
      working-directory: ./backend
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        SECRET_KEY: test-secret-key-for-testing-only
        DEBUG: True
        DJANGO_ENV: test
        DJANGO_SETTINGS_MODULE: projectmeats.settings.test
        # Test-specific superuser credentials (mocked in tests)
        STAGING_SUPERUSER_USERNAME: testadmin
        STAGING_SUPERUSER_EMAIL: testadmin@example.com
        STAGING_SUPERUSER_PASSWORD: testpass123
        PRODUCTION_SUPERUSER_USERNAME: testadmin
        PRODUCTION_SUPERUSER_EMAIL: testadmin@example.com
        PRODUCTION_SUPERUSER_PASSWORD: testpass123
      run: |
        python manage.py test apps/

    - name: üîç Run code quality checks
      working-directory: ./backend
      continue-on-error: true
      run: |
        if pip show flake8 >/dev/null 2>&1; then
          echo "Running flake8 linting..."
          flake8 . --exclude=migrations --max-line-length=120 || echo "‚ö†Ô∏è Flake8 found style issues (non-blocking)"
        fi

        if pip show black >/dev/null 2>&1; then
          echo "Running black formatting check..."
          black --check . --exclude=migrations || echo "‚ö†Ô∏è Black found formatting issues (non-blocking)"
        fi

        echo "‚úÖ Code quality checks completed"

  # ===========================================================================
  # FRONTEND TESTING
  # ===========================================================================
  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true'

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: 'frontend/package-lock.json'

    - name: üì• Install dependencies
      working-directory: ./frontend
      run: npm ci

    - name: üß™ Run tests
      working-directory: ./frontend
      run: npm run test:ci

    - name: üîç Run type check
      working-directory: ./frontend
      run: npm run type-check

  # ===========================================================================
  # BACKEND DEVELOPMENT DEPLOYMENT
  # ===========================================================================
  deploy-backend-development:
    name: Deploy Backend to Development
    runs-on: ubuntu-latest
    needs: [detect-changes, test-backend]
    if: |
      always() &&
      needs.detect-changes.outputs.backend == 'true' &&
      github.ref == 'refs/heads/development' &&
      (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    environment: dev-backend

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.DEV_HOST }} >> ~/.ssh/known_hosts

    - name: üîç Validate DB Configuration
      run: |
        # Set default DB_ENGINE if not provided or empty
        DB_ENGINE_VALUE="${{ secrets.DEVELOPMENT_DB_ENGINE }}"
        if [ -z "$DB_ENGINE_VALUE" ] || [ "$DB_ENGINE_VALUE" = "" ]; then
          echo "‚ö†Ô∏è DEVELOPMENT_DB_ENGINE secret is empty, will use SQLite fallback"
          echo "üìù To use PostgreSQL, set DEVELOPMENT_DB_ENGINE='django.db.backends.postgresql' in GitHub Secrets"
          echo "   Navigate to: Settings ‚Üí Environments ‚Üí dev-backend ‚Üí Add secret"
          echo "DB_ENGINE_FALLBACK=django.db.backends.sqlite3" >> $GITHUB_ENV
        else
          echo "‚úÖ DEVELOPMENT_DB_ENGINE is set to: $DB_ENGINE_VALUE"
          echo "DB_ENGINE_FALLBACK=$DB_ENGINE_VALUE" >> $GITHUB_ENV
        fi

    - name: üöÄ Deploy to Development server
      env:
        SSHPASS: ${{ secrets.DEV_SSH_PASSWORD }}
        GIT_TOKEN: ${{ secrets.GIT_TOKEN }}
        DEVELOPMENT_SUPERUSER_USERNAME: ${{ secrets.DEVELOPMENT_SUPERUSER_USERNAME }}
        DEVELOPMENT_SUPERUSER_EMAIL: ${{ secrets.DEVELOPMENT_SUPERUSER_EMAIL }}
        DEVELOPMENT_SUPERUSER_PASSWORD: ${{ secrets.DEVELOPMENT_SUPERUSER_PASSWORD }}
        DEVELOPMENT_DB_ENGINE: ${{ env.DB_ENGINE_FALLBACK }}
        DEVELOPMENT_DB_NAME: ${{ secrets.DEVELOPMENT_DB_NAME }}
        DEVELOPMENT_DB_USER: ${{ secrets.DEVELOPMENT_DB_USER }}
        DEVELOPMENT_DB_PASSWORD: ${{ secrets.DEVELOPMENT_DB_PASSWORD }}
        DEVELOPMENT_DB_HOST: ${{ secrets.DEVELOPMENT_DB_HOST }}
        DEVELOPMENT_DB_PORT: ${{ secrets.DEVELOPMENT_DB_PORT }}
      run: |
        cat > deploy_script.sh << 'DEPLOY_SCRIPT'
        #!/bin/bash
        set -e

        echo "üîÑ Starting Development Backend deployment..."

        cd /home/django/ProjectMeats

        echo "üì¶ Creating backup..."
        if [ -d "backend_backup" ]; then
          rm -rf backend_backup
        fi
        cp -r backend backend_backup

        echo "üîê Configuring git authentication..."
        git remote set-url origin https://${GIT_TOKEN}@github.com/Meats-Central/ProjectMeats.git

        echo "üì• Pulling latest changes..."
        git stash push -m "Deployment backup $(date)" || true
        git clean -fd
        git fetch origin development
        git checkout development
        git reset --hard origin/development

        echo "‚úÖ Successfully updated to latest development branch"

        echo "üêç Activating virtual environment..."
        cd backend
        source venv/bin/activate

        echo "üì¶ Installing dependencies..."
        pip install -r requirements.txt

        echo "üìÅ Ensuring logs directory exists..."
        mkdir -p logs
        chown -R django:www-data logs

        # SQLite permission fix (if using SQLite - DEPRECATED)
        if [ "${DEVELOPMENT_DB_ENGINE}" = "django.db.backends.sqlite3" ]; then
          echo "‚ö†Ô∏è Fixing SQLite permissions (DEPRECATED - migrate to PostgreSQL)..."
          if [ -f "db.sqlite3" ]; then
            sudo chown $USER:$USER db.sqlite3 2>/dev/null || chown $USER:$USER db.sqlite3
            chmod 664 db.sqlite3
          fi
        fi

        echo "üîç Checking database connection..."
        DB_ENGINE="${DEVELOPMENT_DB_ENGINE}" \
        DB_NAME="${DEVELOPMENT_DB_NAME}" \
        DB_USER="${DEVELOPMENT_DB_USER}" \
        DB_PASSWORD="${DEVELOPMENT_DB_PASSWORD}" \
        DB_HOST="${DEVELOPMENT_DB_HOST}" \
        DB_PORT="${DEVELOPMENT_DB_PORT}" \
        python manage.py check --database default

        echo "üóÉÔ∏è Running database migrations..."
        DB_ENGINE="${DEVELOPMENT_DB_ENGINE}" \
        DB_NAME="${DEVELOPMENT_DB_NAME}" \
        DB_USER="${DEVELOPMENT_DB_USER}" \
        DB_PASSWORD="${DEVELOPMENT_DB_PASSWORD}" \
        DB_HOST="${DEVELOPMENT_DB_HOST}" \
        DB_PORT="${DEVELOPMENT_DB_PORT}" \
        python manage.py migrate

        echo "üë§ Setting up superuser with environment password..."
        DJANGO_ENV=development \
        DEVELOPMENT_SUPERUSER_USERNAME="${DEVELOPMENT_SUPERUSER_USERNAME}" \
        DEVELOPMENT_SUPERUSER_EMAIL="${DEVELOPMENT_SUPERUSER_EMAIL}" \
        DEVELOPMENT_SUPERUSER_PASSWORD="${DEVELOPMENT_SUPERUSER_PASSWORD}" \
        python manage.py setup_superuser

        echo "üë§ Creating superuser and root tenant..."
        DJANGO_ENV=development \
        DEVELOPMENT_SUPERUSER_USERNAME="${DEVELOPMENT_SUPERUSER_USERNAME}" \
        DEVELOPMENT_SUPERUSER_EMAIL="${DEVELOPMENT_SUPERUSER_EMAIL}" \
        DEVELOPMENT_SUPERUSER_PASSWORD="${DEVELOPMENT_SUPERUSER_PASSWORD}" \
        python manage.py create_super_tenant --verbosity 2

        echo "üìÅ Collecting static files..."
        python manage.py collectstatic --noinput

        echo "üß™ Testing Django configuration..."
        python manage.py check

        echo "‚úÖ Backend deployment completed successfully!"
        DEPLOY_SCRIPT

        # Pass environment variables to the remote script
        sshpass -e ssh ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }} \
          "export GIT_TOKEN='${GIT_TOKEN}' && \
           export DEVELOPMENT_SUPERUSER_USERNAME='${DEVELOPMENT_SUPERUSER_USERNAME}' && \
           export DEVELOPMENT_SUPERUSER_EMAIL='${DEVELOPMENT_SUPERUSER_EMAIL}' && \
           export DEVELOPMENT_SUPERUSER_PASSWORD='${DEVELOPMENT_SUPERUSER_PASSWORD}' && \
           export DEVELOPMENT_DB_ENGINE='${DEVELOPMENT_DB_ENGINE}' && \
           export DEVELOPMENT_DB_NAME='${DEVELOPMENT_DB_NAME}' && \
           export DEVELOPMENT_DB_USER='${DEVELOPMENT_DB_USER}' && \
           export DEVELOPMENT_DB_PASSWORD='${DEVELOPMENT_DB_PASSWORD}' && \
           export DEVELOPMENT_DB_HOST='${DEVELOPMENT_DB_HOST}' && \
           export DEVELOPMENT_DB_PORT='${DEVELOPMENT_DB_PORT}' && \
           cat > /tmp/deploy_script.sh" < deploy_script.sh
        
        sshpass -e ssh ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }} \
          "chmod +x /tmp/deploy_script.sh && \
           export GIT_TOKEN='${GIT_TOKEN}' && \
           export DEVELOPMENT_SUPERUSER_USERNAME='${DEVELOPMENT_SUPERUSER_USERNAME}' && \
           export DEVELOPMENT_SUPERUSER_EMAIL='${DEVELOPMENT_SUPERUSER_EMAIL}' && \
           export DEVELOPMENT_SUPERUSER_PASSWORD='${DEVELOPMENT_SUPERUSER_PASSWORD}' && \
           export DEVELOPMENT_DB_ENGINE='${DEVELOPMENT_DB_ENGINE}' && \
           export DEVELOPMENT_DB_NAME='${DEVELOPMENT_DB_NAME}' && \
           export DEVELOPMENT_DB_USER='${DEVELOPMENT_DB_USER}' && \
           export DEVELOPMENT_DB_PASSWORD='${DEVELOPMENT_DB_PASSWORD}' && \
           export DEVELOPMENT_DB_HOST='${DEVELOPMENT_DB_HOST}' && \
           export DEVELOPMENT_DB_PORT='${DEVELOPMENT_DB_PORT}' && \
           /tmp/deploy_script.sh"

    - name: üîÑ Restart backend services
      env:
        SSHPASS: ${{ secrets.DEV_SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }} << 'RESTART_SCRIPT'
        echo "üîÑ Restarting backend services..."
        sudo systemctl restart gunicorn.service
        sleep 5
        sudo systemctl status gunicorn.service
        sudo systemctl reload nginx
        echo "‚úÖ Services restarted successfully!"
        RESTART_SCRIPT

    - name: üè• Health check
      run: |
        echo "üè• Performing health check..."
        sleep 15

        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          if curl -f -s "${{ secrets.DEV_API_URL }}/api/v1/health/" > /dev/null; then
            echo "‚úÖ Development Backend is healthy!"
            break
          else
            if [ $i -eq 5 ]; then
              echo "‚ùå Development Backend health check failed after 5 attempts"
              exit 1
            fi
            echo "Retrying in 10 seconds..."
            sleep 10
          fi
        done

    - name: üìß Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Development Backend deployment successful!"
          echo "üåê API URL: ${{ secrets.DEV_API_URL }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
        else
          echo "‚ùå Development Backend deployment failed!"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
        fi

  # ===========================================================================
  # BACKEND STAGING DEPLOYMENT
  # ===========================================================================
  deploy-backend-staging:
    name: Deploy Backend to UAT Staging
    runs-on: ubuntu-latest
    needs: [detect-changes, test-backend]
    if: |
      always() &&
      needs.detect-changes.outputs.backend == 'true' &&
      github.ref == 'refs/heads/development' &&
      (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    environment: uat2-backend

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

    - name: üöÄ Deploy to UAT staging server
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
        GIT_TOKEN: ${{ secrets.GIT_TOKEN }}
        STAGING_SUPERUSER_USERNAME: ${{ secrets.STAGING_SUPERUSER_USERNAME }}
        STAGING_SUPERUSER_EMAIL: ${{ secrets.STAGING_SUPERUSER_EMAIL }}
        STAGING_SUPERUSER_PASSWORD: ${{ secrets.STAGING_SUPERUSER_PASSWORD }}
      run: |
        echo "üîç Debug: Verifying secrets are set (masked)"
        echo "STAGING_SUPERUSER_USERNAME is set: $([ -n "$STAGING_SUPERUSER_USERNAME" ] && echo 'YES' || echo 'NO')"
        echo "STAGING_SUPERUSER_EMAIL is set: $([ -n "$STAGING_SUPERUSER_EMAIL" ] && echo 'YES' || echo 'NO')"
        echo "STAGING_SUPERUSER_PASSWORD is set: $([ -n "$STAGING_SUPERUSER_PASSWORD" ] && echo 'YES' || echo 'NO')"
        
        cat > deploy_script.sh << 'DEPLOY_SCRIPT'
        #!/bin/bash
        set -e

        echo "üîÑ Starting UAT Backend deployment..."

        cd /home/django/ProjectMeats

        echo "üì¶ Creating backup..."
        if [ -d "backend_backup" ]; then
          rm -rf backend_backup
        fi
        cp -r backend backend_backup

        echo "üîê Configuring git authentication..."
        git remote set-url origin https://${GIT_TOKEN}@github.com/Meats-Central/ProjectMeats.git

        echo "üì• Pulling latest changes..."
        git stash push -m "Deployment backup $(date)" || true
        git clean -fd
        git fetch origin development
        git checkout development
        git reset --hard origin/development

        echo "‚úÖ Successfully updated to latest development branch"

        echo "üêç Activating virtual environment..."
        cd backend
        source venv/bin/activate

        echo "üì¶ Installing dependencies..."
        pip install -r requirements.txt

        echo "üìÅ Ensuring logs directory exists..."
        mkdir -p logs
        chown -R django:www-data logs

        echo "üóÉÔ∏è Running database migrations..."
        python manage.py migrate

        echo "üë§ Setting up superuser with environment password..."
        DJANGO_ENV=staging \
        STAGING_SUPERUSER_USERNAME="${STAGING_SUPERUSER_USERNAME}" \
        STAGING_SUPERUSER_EMAIL="${STAGING_SUPERUSER_EMAIL}" \
        STAGING_SUPERUSER_PASSWORD="${STAGING_SUPERUSER_PASSWORD}" \
        python manage.py setup_superuser --verbosity 3

        echo "üë§ Creating superuser and root tenant..."
        DJANGO_ENV=staging \
        STAGING_SUPERUSER_USERNAME="${STAGING_SUPERUSER_USERNAME}" \
        STAGING_SUPERUSER_EMAIL="${STAGING_SUPERUSER_EMAIL}" \
        STAGING_SUPERUSER_PASSWORD="${STAGING_SUPERUSER_PASSWORD}" \
        python manage.py create_super_tenant --verbosity 2

        echo "üìÅ Collecting static files..."
        python manage.py collectstatic --noinput

        echo "üß™ Testing Django configuration..."
        python manage.py check

        echo "‚úÖ Backend deployment completed successfully!"
        DEPLOY_SCRIPT

        # Pass environment variables to the remote script
        sshpass -e ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
          "export GIT_TOKEN='${GIT_TOKEN}' && \
           export STAGING_SUPERUSER_USERNAME='${STAGING_SUPERUSER_USERNAME}' && \
           export STAGING_SUPERUSER_EMAIL='${STAGING_SUPERUSER_EMAIL}' && \
           export STAGING_SUPERUSER_PASSWORD='${STAGING_SUPERUSER_PASSWORD}' && \
           cat > /tmp/deploy_script.sh" < deploy_script.sh
        
        sshpass -e ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
          "chmod +x /tmp/deploy_script.sh && \
           export GIT_TOKEN='${GIT_TOKEN}' && \
           export STAGING_SUPERUSER_USERNAME='${STAGING_SUPERUSER_USERNAME}' && \
           export STAGING_SUPERUSER_EMAIL='${STAGING_SUPERUSER_EMAIL}' && \
           export STAGING_SUPERUSER_PASSWORD='${STAGING_SUPERUSER_PASSWORD}' && \
           /tmp/deploy_script.sh"

    - name: üîÑ Restart backend services
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'RESTART_SCRIPT'
        echo "üîÑ Restarting backend services..."
        sudo systemctl restart gunicorn.service
        sleep 5
        sudo systemctl status gunicorn.service
        sudo systemctl reload nginx
        echo "‚úÖ Services restarted successfully!"
        RESTART_SCRIPT

    - name: üè• Health check
      run: |
        echo "üè• Performing health check..."
        sleep 15

        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          if curl -f -s "${{ secrets.STAGING_API_URL }}/api/v1/health/" > /dev/null; then
            echo "‚úÖ UAT Backend is healthy!"
            break
          else
            if [ $i -eq 5 ]; then
              echo "‚ùå UAT Backend health check failed after 5 attempts"
              exit 1
            fi
            echo "Retrying in 10 seconds..."
            sleep 10
          fi
        done

    - name: üìß Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ UAT Backend deployment successful!"
          echo "üåê API URL: ${{ secrets.STAGING_API_URL }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
        else
          echo "‚ùå UAT Backend deployment failed!"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
        fi

  # ===========================================================================
  # BACKEND PRODUCTION DEPLOYMENT
  # ===========================================================================
  deploy-backend-production:
    name: Deploy Backend to Production
    runs-on: ubuntu-latest
    needs: [detect-changes, test-backend]
    if: |
      always() &&
      needs.detect-changes.outputs.backend == 'true' &&
      github.ref == 'refs/heads/main' &&
      (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    environment: prod2-backend

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: üöÄ Deploy to Production server
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
        GIT_TOKEN: ${{ secrets.GIT_TOKEN }}
        PRODUCTION_SUPERUSER_USERNAME: ${{ secrets.PRODUCTION_SUPERUSER_USERNAME }}
        PRODUCTION_SUPERUSER_EMAIL: ${{ secrets.PRODUCTION_SUPERUSER_EMAIL }}
        PRODUCTION_SUPERUSER_PASSWORD: ${{ secrets.PRODUCTION_SUPERUSER_PASSWORD }}
      run: |
        cat > deploy_script.sh << 'DEPLOY_SCRIPT'
        #!/bin/bash
        set -e

        echo "üîÑ Starting PRODUCTION Backend deployment..."

        cd /home/django/ProjectMeats

        echo "üì¶ Creating backup..."
        if [ -d "backend_backup" ]; then
          rm -rf backend_backup
        fi
        cp -r backend backend_backup

        echo "üîê Configuring git authentication..."
        git remote set-url origin https://oauth2:${GIT_TOKEN}@github.com/Meats-Central/ProjectMeats.git

        echo "üì• Pulling latest changes from main branch..."
        git stash push -m "Production deployment backup $(date)" || true
        git clean -fd
        git fetch origin main
        git checkout main
        git reset --hard origin/main

        echo "‚úÖ Successfully updated to latest main branch"

        echo "üêç Activating virtual environment..."
        cd backend
        source venv/bin/activate

        echo "üì¶ Installing dependencies..."
        pip install -r requirements.txt

        echo "üìÅ Ensuring logs directory exists..."
        mkdir -p logs
        chown -R django:www-data logs

        echo "üóÉÔ∏è Running database migrations..."
        python manage.py migrate

        echo "üë§ Setting up superuser with environment password..."
        DJANGO_ENV=production \
        PRODUCTION_SUPERUSER_USERNAME="${PRODUCTION_SUPERUSER_USERNAME}" \
        PRODUCTION_SUPERUSER_EMAIL="${PRODUCTION_SUPERUSER_EMAIL}" \
        PRODUCTION_SUPERUSER_PASSWORD="${PRODUCTION_SUPERUSER_PASSWORD}" \
        python manage.py setup_superuser

        echo "üë§ Creating superuser and root tenant..."
        DJANGO_ENV=production \
        PRODUCTION_SUPERUSER_USERNAME="${PRODUCTION_SUPERUSER_USERNAME}" \
        PRODUCTION_SUPERUSER_EMAIL="${PRODUCTION_SUPERUSER_EMAIL}" \
        PRODUCTION_SUPERUSER_PASSWORD="${PRODUCTION_SUPERUSER_PASSWORD}" \
        python manage.py create_super_tenant --verbosity 2

        echo "üìÅ Collecting static files..."
        python manage.py collectstatic --noinput

        echo "üß™ Testing Django configuration..."
        python manage.py check --deploy

        echo "‚úÖ Production backend deployment completed successfully!"
        DEPLOY_SCRIPT

        # Pass environment variables to the remote script
        sshpass -e ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} \
          "export GIT_TOKEN='${GIT_TOKEN}' && \
           export PRODUCTION_SUPERUSER_USERNAME='${PRODUCTION_SUPERUSER_USERNAME}' && \
           export PRODUCTION_SUPERUSER_EMAIL='${PRODUCTION_SUPERUSER_EMAIL}' && \
           export PRODUCTION_SUPERUSER_PASSWORD='${PRODUCTION_SUPERUSER_PASSWORD}' && \
           cat > /tmp/deploy_script.sh" < deploy_script.sh
        
        sshpass -e ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} \
          "chmod +x /tmp/deploy_script.sh && \
           export GIT_TOKEN='${GIT_TOKEN}' && \
           export PRODUCTION_SUPERUSER_USERNAME='${PRODUCTION_SUPERUSER_USERNAME}' && \
           export PRODUCTION_SUPERUSER_EMAIL='${PRODUCTION_SUPERUSER_EMAIL}' && \
           export PRODUCTION_SUPERUSER_PASSWORD='${PRODUCTION_SUPERUSER_PASSWORD}' && \
           /tmp/deploy_script.sh"

    - name: üîÑ Restart production services
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'RESTART_SCRIPT'
        echo "üîÑ Restarting production backend services..."
        sudo systemctl restart gunicorn.service
        sleep 10
        sudo systemctl status gunicorn.service
        sudo systemctl reload nginx
        echo "‚úÖ Production services restarted successfully!"
        RESTART_SCRIPT

    - name: üè• Health check
      run: |
        echo "üè• Performing production health check..."
        sleep 20

        for i in {1..10}; do
          echo "Health check attempt $i/10..."
          if curl -f -s "${{ secrets.PRODUCTION_API_URL }}/api/v1/health/" > /dev/null; then
            echo "‚úÖ Production Backend is healthy!"
            break
          else
            if [ $i -eq 10 ]; then
              echo "‚ùå Production Backend health check failed after 10 attempts"
              echo "üö® PRODUCTION DEPLOYMENT MAY HAVE FAILED!"
              exit 1
            fi
            echo "Retrying in 15 seconds..."
            sleep 15
          fi
        done

    - name: üìß Production deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üéâ PRODUCTION Backend deployment SUCCESSFUL! üéâ"
          echo "üåê Production API URL: ${{ secrets.PRODUCTION_API_URL }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
          echo "üöÄ Production is now live with latest changes!"
        else
          echo "üö® PRODUCTION Backend deployment FAILED! üö®"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
          echo "‚ö†Ô∏è Please check logs and potentially rollback!"
        fi

  # ===========================================================================
  # FRONTEND DEVELOPMENT DEPLOYMENT
  # ===========================================================================
  deploy-frontend-development:
    name: Deploy Frontend to Development
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend]
    if: |
      always() &&
      needs.detect-changes.outputs.frontend == 'true' &&
      github.ref == 'refs/heads/development' &&
      (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')
    environment: dev-frontend

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: 'frontend/package-lock.json'

    - name: üì• Install dependencies
      working-directory: ./frontend
      run: npm ci

    - name: üèóÔ∏è Create development .env file
      working-directory: ./frontend
      run: |
        cat > .env.production << EOF
        REACT_APP_API_BASE_URL=${{ secrets.REACT_APP_API_BASE_URL }}
        NODE_ENV=production
        REACT_APP_ENVIRONMENT=development
        REACT_APP_AI_ASSISTANT_ENABLED=${{ secrets.REACT_APP_AI_ASSISTANT_ENABLED }}
        REACT_APP_ENABLE_DOCUMENT_UPLOAD=${{ secrets.REACT_APP_ENABLE_DOCUMENT_UPLOAD }}
        REACT_APP_ENABLE_CHAT_EXPORT=${{ secrets.REACT_APP_ENABLE_CHAT_EXPORT }}
        REACT_APP_MAX_FILE_SIZE=${{ secrets.REACT_APP_MAX_FILE_SIZE }}
        REACT_APP_SUPPORTED_FILE_TYPES=${{ secrets.REACT_APP_SUPPORTED_FILE_TYPES }}
        REACT_APP_ENABLE_DEBUG=${{ secrets.REACT_APP_ENABLE_DEBUG }}
        REACT_APP_ENABLE_DEVTOOLS=${{ secrets.REACT_APP_ENABLE_DEVTOOLS }}
        EOF

    - name: üèóÔ∏è Build React app
      working-directory: ./frontend
      run: npm run build

    - name: üì¶ Create deployment archive
      run: |
        cd frontend/build
        tar -czf ../../frontend-build.tar.gz .

    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.DEV_HOST }} >> ~/.ssh/known_hosts

    - name: üöÄ Deploy to Development server
      env:
        SSHPASS: ${{ secrets.DEV_SSH_PASSWORD }}
      run: |
        sshpass -e scp frontend-build.tar.gz ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }}:/tmp/

        sshpass -e ssh ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }} << 'DEPLOY_SCRIPT'
          set -e

          echo "üîÑ Starting Development deployment..."

          if [ -d "/var/www/ProjectMeats/frontend/build" ]; then
            echo "üì¶ Creating backup..."
            sudo cp -r /var/www/ProjectMeats/frontend/build /var/www/ProjectMeats/frontend/build.backup.$(date +%Y%m%d_%H%M%S)
          fi

          echo "üöÄ Deploying new build..."
          cd /tmp
          mkdir -p frontend-build-new
          tar -xzf frontend-build.tar.gz -C frontend-build-new/

          sudo rm -rf /var/www/ProjectMeats/frontend/build
          sudo mkdir -p /var/www/ProjectMeats/frontend/build
          sudo cp -r frontend-build-new/* /var/www/ProjectMeats/frontend/build/

          sudo chown -R www-data:www-data /var/www/ProjectMeats/frontend/build
          sudo chmod -R 755 /var/www/ProjectMeats/frontend/build

          sudo nginx -t && sudo systemctl reload nginx

          rm -rf /tmp/frontend-build.tar.gz /tmp/frontend-build-new

          echo "‚úÖ Development deployment completed!"
        DEPLOY_SCRIPT

    - name: üè• Health check
      run: |
        sleep 10
        if curl -f -s "${{ secrets.DEV_URL }}" > /dev/null; then
          echo "‚úÖ Development frontend is healthy"
        else
          echo "‚ùå Development frontend health check failed"
          exit 1
        fi

    - name: üßπ Cleanup
      if: always()
      run: rm -f frontend-build.tar.gz

  # ===========================================================================
  # FRONTEND STAGING DEPLOYMENT
  # ===========================================================================
  deploy-frontend-staging:
    name: Deploy Frontend to UAT Staging
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend]
    if: |
      always() &&
      needs.detect-changes.outputs.frontend == 'true' &&
      github.ref == 'refs/heads/development' &&
      (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')
    environment: uat2

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: 'frontend/package-lock.json'

    - name: üì• Install dependencies
      working-directory: ./frontend
      run: npm ci

    - name: üèóÔ∏è Create staging .env file
      working-directory: ./frontend
      run: |
        cat > .env.production << EOF
        REACT_APP_API_BASE_URL=${{ secrets.REACT_APP_API_BASE_URL }}
        NODE_ENV=production
        REACT_APP_ENVIRONMENT=staging
        REACT_APP_AI_ASSISTANT_ENABLED=${{ secrets.REACT_APP_AI_ASSISTANT_ENABLED }}
        REACT_APP_ENABLE_DOCUMENT_UPLOAD=${{ secrets.REACT_APP_ENABLE_DOCUMENT_UPLOAD }}
        REACT_APP_ENABLE_CHAT_EXPORT=${{ secrets.REACT_APP_ENABLE_CHAT_EXPORT }}
        REACT_APP_MAX_FILE_SIZE=${{ secrets.REACT_APP_MAX_FILE_SIZE }}
        REACT_APP_SUPPORTED_FILE_TYPES=${{ secrets.REACT_APP_SUPPORTED_FILE_TYPES }}
        REACT_APP_ENABLE_DEBUG=${{ secrets.REACT_APP_ENABLE_DEBUG }}
        REACT_APP_ENABLE_DEVTOOLS=${{ secrets.REACT_APP_ENABLE_DEVTOOLS }}
        EOF

    - name: üèóÔ∏è Build React app
      working-directory: ./frontend
      run: npm run build

    - name: üì¶ Create deployment archive
      run: |
        cd frontend/build
        tar -czf ../../frontend-build.tar.gz .

    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

    - name: üöÄ Deploy to UAT staging server
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e scp frontend-build.tar.gz ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:/tmp/

        sshpass -e ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'DEPLOY_SCRIPT'
          set -e

          echo "üîÑ Starting UAT deployment..."

          if [ -d "/var/www/ProjectMeats/frontend/build" ]; then
            echo "üì¶ Creating backup..."
            sudo cp -r /var/www/ProjectMeats/frontend/build /var/www/ProjectMeats/frontend/build.backup.$(date +%Y%m%d_%H%M%S)
          fi

          echo "üöÄ Deploying new build..."
          cd /tmp
          mkdir -p frontend-build-new
          tar -xzf frontend-build.tar.gz -C frontend-build-new/

          sudo rm -rf /var/www/ProjectMeats/frontend/build
          sudo mkdir -p /var/www/ProjectMeats/frontend/build
          sudo cp -r frontend-build-new/* /var/www/ProjectMeats/frontend/build/

          sudo chown -R www-data:www-data /var/www/ProjectMeats/frontend/build
          sudo chmod -R 755 /var/www/ProjectMeats/frontend/build

          sudo nginx -t && sudo systemctl reload nginx

          rm -rf /tmp/frontend-build.tar.gz /tmp/frontend-build-new

          echo "‚úÖ UAT deployment completed!"
        DEPLOY_SCRIPT

    - name: üè• Health check
      run: |
        sleep 10
        if curl -f -s "${{ secrets.STAGING_URL }}" > /dev/null; then
          echo "‚úÖ UAT frontend is healthy"
        else
          echo "‚ùå UAT frontend health check failed"
          exit 1
        fi

    - name: üßπ Cleanup
      if: always()
      run: rm -f frontend-build.tar.gz

  # ===========================================================================
  # FRONTEND PRODUCTION DEPLOYMENT
  # ===========================================================================
  deploy-frontend-production:
    name: Deploy Frontend to Production
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend]
    if: |
      always() &&
      needs.detect-changes.outputs.frontend == 'true' &&
      github.ref == 'refs/heads/main' &&
      (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')
    environment: prod2-frontend

    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4

    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: 'frontend/package-lock.json'

    - name: üì• Install dependencies
      working-directory: ./frontend
      run: npm ci

    - name: üèóÔ∏è Create production .env file
      working-directory: ./frontend
      run: |
        cat > .env.production << EOF
        REACT_APP_API_BASE_URL=${{ secrets.REACT_APP_API_BASE_URL }}
        NODE_ENV=production
        REACT_APP_ENVIRONMENT=production
        REACT_APP_AI_ASSISTANT_ENABLED=${{ secrets.REACT_APP_AI_ASSISTANT_ENABLED }}
        REACT_APP_ENABLE_DOCUMENT_UPLOAD=${{ secrets.REACT_APP_ENABLE_DOCUMENT_UPLOAD }}
        REACT_APP_ENABLE_CHAT_EXPORT=${{ secrets.REACT_APP_ENABLE_CHAT_EXPORT }}
        REACT_APP_MAX_FILE_SIZE=${{ secrets.REACT_APP_MAX_FILE_SIZE }}
        REACT_APP_SUPPORTED_FILE_TYPES=${{ secrets.REACT_APP_SUPPORTED_FILE_TYPES }}
        REACT_APP_ENABLE_DEBUG=false
        REACT_APP_ENABLE_DEVTOOLS=false
        EOF

    - name: üèóÔ∏è Build React app for production
      working-directory: ./frontend
      run: |
        echo "Building React application for PRODUCTION..."
        npm run build

    - name: üì¶ Create deployment archive
      run: |
        cd frontend/build
        tar -czf ../../frontend-build.tar.gz .

    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: üöÄ Deploy to Production frontend server
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e scp frontend-build.tar.gz ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/

        sshpass -e ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'DEPLOY_SCRIPT'
        set -e

        echo "üîÑ Starting PRODUCTION Frontend deployment..."

        if [ -d "/var/www/ProjectMeats/frontend/build" ]; then
          echo "üì¶ Creating backup..."
          sudo cp -r /var/www/ProjectMeats/frontend/build /var/www/ProjectMeats/frontend/build.backup.$(date +%Y%m%d_%H%M%S)
        fi

        echo "üöÄ Deploying new production build..."
        cd /tmp
        mkdir -p frontend-build-new
        tar -xzf frontend-build.tar.gz -C frontend-build-new/

        sudo rm -rf /var/www/ProjectMeats/frontend/build
        sudo mkdir -p /var/www/ProjectMeats/frontend/build
        sudo cp -r frontend-build-new/* /var/www/ProjectMeats/frontend/build/

        sudo chown -R www-data:www-data /var/www/ProjectMeats/frontend/build
        sudo chmod -R 755 /var/www/ProjectMeats/frontend/build

        sudo nginx -t && sudo systemctl reload nginx

        rm -rf /tmp/frontend-build.tar.gz /tmp/frontend-build-new

        echo "‚úÖ PRODUCTION Frontend deployment completed!"
        DEPLOY_SCRIPT

    - name: üè• Health check
      run: |
        echo "üè• Performing production health check..."
        sleep 15

        for i in {1..8}; do
          echo "Health check attempt $i/8..."
          if curl -f -s "${{ secrets.PRODUCTION_URL }}" > /dev/null; then
            echo "‚úÖ PRODUCTION Frontend is healthy!"
            break
          else
            if [ $i -eq 8 ]; then
              echo "‚ùå PRODUCTION Frontend health check failed after 8 attempts"
              echo "üö® PRODUCTION DEPLOYMENT MAY HAVE FAILED!"
              exit 1
            fi
            echo "Retrying in 10 seconds..."
            sleep 10
          fi
        done

    - name: üßπ Cleanup
      if: always()
      run: rm -f frontend-build.tar.gz

    - name: üìß Production deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üéâ PRODUCTION Frontend deployment SUCCESSFUL! üéâ"
          echo "üåê Production URL: ${{ secrets.PRODUCTION_URL }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
          echo "üöÄ Production website is now live with latest changes!"
        else
          echo "üö® PRODUCTION Frontend deployment FAILED! üö®"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üïí Time: $(date)"
          echo "‚ö†Ô∏è Please check logs and potentially rollback!"
        fi

  # ===========================================================================
  # ROLLBACK JOBS (Manual trigger only)
  # ===========================================================================
  rollback-backend-development:
    name: Rollback Backend Development
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback' && github.ref == 'refs/heads/development'
    environment: dev-backend

    steps:
    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.DEV_HOST }} >> ~/.ssh/known_hosts

    - name: ‚è™ Rollback to previous version
      env:
        SSHPASS: ${{ secrets.DEV_SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }} << 'ROLLBACK_SCRIPT'
        set -e

        echo "üîÑ Starting Development rollback process..."

        cd /home/django/ProjectMeats

        if [ ! -d "backend_backup" ]; then
          echo "‚ùå No backup found for rollback!"
          exit 1
        fi

        echo "üì¶ Rolling back to previous version..."

        sudo systemctl stop gunicorn.service
        rm -rf backend
        mv backend_backup backend
        sudo systemctl start gunicorn.service
        sleep 10
        sudo systemctl reload nginx

        echo "‚úÖ Development rollback completed successfully!"
        ROLLBACK_SCRIPT

  rollback-backend-staging:
    name: Rollback Backend Staging
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback' && github.ref == 'refs/heads/development'
    environment: uat2-backend

    steps:
    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

    - name: ‚è™ Rollback to previous version
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ROLLBACK_SCRIPT'
        set -e

        echo "üîÑ Starting rollback process..."

        cd /home/django/ProjectMeats

        if [ ! -d "backend_backup" ]; then
          echo "‚ùå No backup found for rollback!"
          exit 1
        fi

        echo "üì¶ Rolling back to previous version..."

        sudo systemctl stop gunicorn.service
        rm -rf backend
        mv backend_backup backend
        sudo systemctl start gunicorn.service
        sleep 10
        sudo systemctl reload nginx

        echo "‚úÖ Rollback completed successfully!"
        ROLLBACK_SCRIPT

  rollback-backend-production:
    name: Rollback Backend Production
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback' && github.ref == 'refs/heads/main'
    environment: prod2-backend

    steps:
    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: ‚è™ Rollback production to previous version
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ROLLBACK_SCRIPT'
        set -e

        echo "üö® Starting EMERGENCY PRODUCTION rollback process..."

        cd /home/django/ProjectMeats

        if [ ! -d "backend_backup" ]; then
          echo "‚ùå No backup found for rollback!"
          echo "üö® CRITICAL: Cannot rollback production!"
          exit 1
        fi

        echo "üì¶ Rolling back production to previous version..."

        sudo systemctl stop gunicorn.service
        rm -rf backend
        mv backend_backup backend
        sudo systemctl start gunicorn.service
        sleep 15
        sudo systemctl reload nginx

        echo "‚úÖ PRODUCTION rollback completed successfully!"
        echo "üîç Please verify production is working correctly"
        ROLLBACK_SCRIPT

  rollback-frontend-development:
    name: Rollback Frontend Development
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback' && github.ref == 'refs/heads/development'
    environment: dev-frontend

    steps:
    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.DEV_HOST }} >> ~/.ssh/known_hosts

    - name: ‚è™ Rollback development frontend
      env:
        SSHPASS: ${{ secrets.DEV_SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.DEV_USER }}@${{ secrets.DEV_HOST }} << 'ROLLBACK_SCRIPT'
        set -e

        echo "üîÑ Starting Development frontend rollback..."

        BACKUP_DIR=$(find /var/www/ProjectMeats/frontend -maxdepth 1 -type d -name "build.backup.*" 2>/dev/null | sort -r | head -n1)

        if [ -z "$BACKUP_DIR" ]; then
          echo "‚ùå No backup found for rollback!"
          exit 1
        fi

        echo "üì¶ Rolling back to: $BACKUP_DIR"

        sudo rm -rf /var/www/ProjectMeats/frontend/build
        sudo cp -r "$BACKUP_DIR" /var/www/ProjectMeats/frontend/build
        sudo chown -R www-data:www-data /var/www/ProjectMeats/frontend/build
        sudo chmod -R 755 /var/www/ProjectMeats/frontend/build
        sudo systemctl reload nginx

        echo "‚úÖ Development frontend rollback completed!"
        ROLLBACK_SCRIPT

  rollback-frontend-staging:
    name: Rollback Frontend Staging
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback' && github.ref == 'refs/heads/development'
    environment: uat2

    steps:
    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

    - name: ‚è™ Rollback staging frontend
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'ROLLBACK_SCRIPT'
        set -e

        echo "üîÑ Starting UAT Staging frontend rollback..."

        BACKUP_DIR=$(find /var/www/ProjectMeats/frontend -maxdepth 1 -type d -name "build.backup.*" 2>/dev/null | sort -r | head -n1)

        if [ -z "$BACKUP_DIR" ]; then
          echo "‚ùå No backup found for rollback!"
          exit 1
        fi

        echo "üì¶ Rolling back to: $BACKUP_DIR"

        sudo rm -rf /var/www/ProjectMeats/frontend/build
        sudo cp -r "$BACKUP_DIR" /var/www/ProjectMeats/frontend/build
        sudo chown -R www-data:www-data /var/www/ProjectMeats/frontend/build
        sudo chmod -R 755 /var/www/ProjectMeats/frontend/build
        sudo systemctl reload nginx

        echo "‚úÖ UAT Staging frontend rollback completed!"
        ROLLBACK_SCRIPT

  rollback-frontend-production:
    name: Rollback Frontend Production
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback' && github.ref == 'refs/heads/main'
    environment: prod2-frontend

    steps:
    - name: üîê Setup SSH with password authentication
      run: |
        sudo apt-get update
        sudo apt-get install -y sshpass
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: ‚è™ Rollback production frontend
      env:
        SSHPASS: ${{ secrets.SSH_PASSWORD }}
      run: |
        sshpass -e ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ROLLBACK_SCRIPT'
        set -e

        echo "üö® Starting EMERGENCY PRODUCTION frontend rollback..."

        BACKUP_DIR=$(find /var/www/ProjectMeats/frontend -maxdepth 1 -type d -name "build.backup.*" 2>/dev/null | sort -r | head -n1)

        if [ -z "$BACKUP_DIR" ]; then
          echo "‚ùå No backup found for rollback!"
          echo "üö® CRITICAL: Cannot rollback production frontend!"
          exit 1
        fi

        echo "üì¶ Rolling back to: $BACKUP_DIR"

        sudo rm -rf /var/www/ProjectMeats/frontend/build
        sudo cp -r "$BACKUP_DIR" /var/www/ProjectMeats/frontend/build
        sudo chown -R www-data:www-data /var/www/ProjectMeats/frontend/build
        sudo chmod -R 755 /var/www/ProjectMeats/frontend/build
        sudo systemctl reload nginx

        echo "‚úÖ PRODUCTION frontend rollback completed!"
        ROLLBACK_SCRIPT