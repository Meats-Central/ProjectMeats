name: Remote Docker Cleanup
description: Prune Docker artifacts on a remote host; keep last N images per repo and skip images used by running containers.
inputs:
  ssh_host:
    description: "Remote SSH host or IP"
    required: true
  ssh_user:
    description: "Remote SSH username"
    required: true
  ssh_key:
    description: "Private SSH key (PEM). Ignored if ssh_key_path is provided."
    required: false
    default: ""
  ssh_key_path:
    description: "Path to an existing private key file on the runner"
    required: false
    default: ""
  repos:
    description: "Comma-separated repos to retain (e.g. ghcr.io/acme/app-backend,ghcr.io/acme/app-frontend)"
    required: false
    default: ""
  keep:
    description: "How many newest images to keep per repo (excluding images in use)"
    required: false
    default: "2"
runs:
  using: "composite"
  steps:
    - name: Prepare key
      id: key
      shell: bash
      run: |
        set -euo pipefail
        if [[ -n "${{ inputs.ssh_key_path }}" ]]; then
          echo "keypath=${{ inputs.ssh_key_path }}" >> "$GITHUB_OUTPUT"
        else
          umask 077
          printf "%s" "${{ inputs.ssh_key }}" > id_rsa_cleanup
          chmod 600 id_rsa_cleanup
          echo "keypath=$PWD/id_rsa_cleanup" >> "$GITHUB_OUTPUT"
        fi

    - name: Run remote cleanup
      shell: bash
      run: |
        set -euo pipefail
        KEY="${{ steps.key.outputs.keypath }}"
        HOST="${{ inputs.ssh_host }}"
        USER="${{ inputs.ssh_user }}"
        REPOS="${{ inputs.repos }}"
        KEEP="${{ inputs.keep }}"

        # Run the cleanup over SSH; pass KEEP/REPOS into the remote shell env
        ssh -i "$KEY" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          "$USER@$HOST" "KEEP='${KEEP}' REPOS='${REPOS}' bash -s" <<'EOSH'
          set -euo pipefail

          echo "[cleanup] Clearing partial downloads…"
          sudo rm -rf /var/lib/docker/tmp/* || true

          echo "[cleanup] Docker usage before:"
          docker system df -v || true

          echo "[cleanup] Pruning unused images/containers/networks (keeps running & volumes)…"
          docker system prune -af || true

          # Build map of images currently in use so we never remove them
          mapfile -t USED < <(docker ps --format '{{.Image}}' | sort -u)

          in_use() {
            local img="$1"
            for u in "${USED[@]}"; do [[ "$u" == "$img" ]] && return 0; done
            return 1
          }

          IFS=',' read -ra ARR <<< "$REPOS"
          for repo in "${ARR[@]}"; do
            [[ -z "$repo" ]] && continue
            echo "[cleanup] Repo: $repo (keeping newest ${KEEP})"
            # newest first
            mapfile -t TAGS < <(docker image ls "$repo" --format '{{.Repository}}:{{.Tag}} {{.CreatedAt}}' \
                                | sort -rk2 | awk '{print $1}')

            kept=0
            for img in "${TAGS[@]}"; do
              if in_use "$img"; then
                echo "  → in use, skip: $img"
                continue
              fi
              kept=$((kept+1))
              if (( kept > KEEP )); then
                echo "  → remove old: $img"
                docker rmi "$img" || true
              else
                echo "  → keep: $img"
              fi
            done
          done

          echo "[cleanup] Docker usage after:"
          docker system df -v || true
        EOSH

    - name: Cleanup local key (if created)
      if: ${{ always() && inputs.ssh_key_path == '' }}
      shell: bash
      run: |
        shred -u id_rsa_cleanup || rm -f id_rsa_cleanup
